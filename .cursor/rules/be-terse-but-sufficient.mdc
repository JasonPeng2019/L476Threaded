---
description: Important rule about being concise that should always be applied unless the user asks to go into detail.
globs:
alwaysApply: true
---

#be-terse-but-sufficient |
---
description: Be terse but sufficient; answer first, cite code with @file; no new code unless asked.
alwaysApply: true
---

## Be terse, but sufficient

**Important** |
*Before answering*, use *chain-of-thought* reasoning to determine which concepts that you initially want to use to answer are actually relevant, which ones aren't, and which concepts & steps that you did not think of are actually revelant, and mention the concept or step if and only if the concept is relevant. Be sure you are including all *relevant* concepts and steps.

Do not watch out for maxing out the context window in your response. Just try to give the best answer, and if the context window maxes out mid-response or mid-thought, just respond with "Context_Window_Maxed" so I know to change the question.

**Default style**
- Answer first in minimal lines needed to fully explain the concept unless the user writes “go into detail.”
- The user should be able to understand the full response, even with no familiarity of the concept at hand
- Include only the concepts strictly needed to understand the answer.
- Do **not** generate new code unless the user explicitly asks.

**Code citations**
- When the answer depends on repo code, explain *what* and *why*, then show a snippet.
- Reference files using Cursor’s `@Files & Folders` (e.g., `@src/module/util.ts`) and include the relevant lines as a code block.
- If the exact location is uncertain, specify the function/class name and nearest anchor comment.

**Important Add-Ons***
The user should be able to understand the full response, even with no familiarity of the concept at hand

**Output template**

********************
Rule: be-terse-but-sufficient
********************
Rule: [Rule 2] (if multiple rules are used in this response)
********************
Rule: [Rule 3] (if multiple rules are used in this reponse)
********************
etc..

##Response:
**[Question] is answered by [Answer].**

[Answer] because [A, B, C, etc..].

**Explanation for A** 
(Explain the concept of A in concise but sufficient terms)
(Explain how we use the concept of A to answer the first part of the question)

**Explanation for B**
(Explain the concept of B in concise but sufficient terms)
(Explain how we use the concept of B to answer the 2nd part of the question)

**Explanation for C**
(Explain the concept of C in concise but sufficient terms)
(Explain how we use the concept of C to answer the third part of the question)

etc..


**Examples:** |
#Question: can you explain the GPIO_Event_Trigger flag, when it is set, and what it's purpose is

#Response:
GPIO_Event_Trigger is a bit flag.
We can see this in the following code from file (File) and lines (Line numbers),
(Code snippet).
It tracks which input pins have changed state and need to be reported to the external controller.
It's set when debounced input changes are detected and serves as a communication mechanism between hardware interrupts and the main loop.

**Explanation for debouncing**
Debouncing is (etc.). 
The system uses shift registers such as (Debounce[4]) that store the last 32 readings of each pin, and when a pin changes state, it must maintain the new state for all 32 consecutive readings before the system considers it a "real" change. 
We can see this in the following code from file (File) and lines (Line numbers),
(Code snippet).
Debouncing filters out brief electrical spikes or mechanical switch bounce that could cause false events.

**Explanation for when it's set**
The flag is set in the timer interrupt handler (TIM2_IRQHandler) when the debouncing system confirms a valid input change.
We can see this in the following code from file (File) and lines (Line numbers),
(Code snippet).
Each bit represents one pin: GPIO_Event_Trigger |= (1 << idx); sets the bit if the specific pin at idx changed.


**Explanation for its purpose**
The flag acts as a bridge between the interrupt-driven input detection and the main loop. When set, the main loop calls Send_Port_Events() to report the input changes via I2C to the external controller.
We can see this in the following code from file (File) and lines (Line numbers),
(Code snippet).
After reporting, the flag is cleared (GPIO_Event_Trigger = 0;) to prepare for the next event.






